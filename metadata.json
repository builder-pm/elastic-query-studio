{
  "description": "Generated by Gemini.",
  "prompt": "implement\n----------\n# Elasticsearch Query Helper AI Chrome Extension - Complete Development Specification\n\n## Project Overview\n\n### Product Description\nA Chrome extension that converts natural language queries into accurate Elasticsearch DSL queries using a sophisticated multi-agent AI architecture. The system processes user input through specialized AI agents to generate, validate, and optimize Elasticsearch queries for a jobs index.\n\n### Technical Goals\n- **Query Accuracy**: Generate syntactically valid Elasticsearch 7.x queries with >85% success rate\n- **Response Time**: Complete query generation within 15-45 seconds\n- **User Experience**: Intuitive chat interface with multiple query options and debug capabilities\n- **Provider Support**: Multi-LLM provider integration with failover capabilities\n\n---\n\n## Technical Architecture\n\n### System Overview\n```\nUser Input → Intent Parser → Perspective Agent → Query Builder → Validation Agent → Consensus Agent → UI Display\n                ↓\n        Sample Query Database → Enhanced Context for All Agents\n                ↓\n        Multi-Provider LLM System → Gemini/OpenAI/Anthropic/Ollama\n```\n\n### Core Components\n1. **Multi-Agent Processing System**: 5 specialized AI agents working in sequence\n2. **Sample Query Database**: 100+ curated Elasticsearch query examples\n3. **Multi-Provider LLM Integration**: Support for 4 major LLM providers\n4. **Chrome Extension Infrastructure**: Manifest V3 with side panel interface\n5. **Caching Layer**: Multi-level caching for performance optimization\n\n---\n\n## File Structure and Setup\n\n### Complete Project Structure\n```\nelasticsearch-query-helper/\n├── manifest.json\n├── package.json\n├── tsconfig.json\n├── tailwind.config.js\n├── vite.config.ts\n├── src/\n│   ├── background/\n│   │   ├── background.ts\n│   │   ├── agents/\n│   │   │   ├── IntentParserAgent.ts\n│   │   │   ├── PerspectiveAgent.ts\n│   │   │   ├── QueryBuilderAgent.ts\n│   │   │   ├── ValidationAgent.ts\n│   │   │   ├── ConsensusAgent.ts\n│   │   │   └── AgentOrchestrator.ts\n│   │   └── services/\n│   │       ├── LLMClient.ts\n│   │       ├── CacheManager.ts\n│   │       └── StorageManager.ts\n│   ├── sidepanel/\n│   │   ├── index.html\n│   │   ├── sidepanel.tsx\n│   │   ├── App.tsx\n│   │   ├── components/\n│   │   │   ├── ChatInterface.tsx\n│   │   │   ├── QueryDisplay.tsx\n│   │   │   ├── QueryOptionCard.tsx\n│   │   │   ├── SettingsModal.tsx\n│   │   │   ├── DebugPanel.tsx\n│   │   │   └── LoadingSpinner.tsx\n│   │   └── hooks/\n│   │       ├── useStorage.ts\n│   │       ├── useLLMConfig.ts\n│   │       └── useDebugMode.ts\n│   ├── shared/\n│   │   ├── types/\n│   │   │   ├── agents.ts\n│   │   │   ├── elasticsearch.ts\n│   │   │   ├── llm.ts\n│   │   │   └── ui.ts\n│   │   ├── config/\n│   │   │   ├── llm-providers.ts\n│   │   │   ├── elasticsearch-schema.ts\n│   │   │   └── constants.ts\n│   │   └── utils/\n│   │       ├── validation.ts\n│   │       ├── query-builder.ts\n│   │       └── error-handling.ts\n│   └── data/\n│       ├── sample-queries.json\n│       ├── jobs-index-schema.json\n│       └── prompt-templates.json\n├── tests/\n│   ├── agents/\n│   │   ├── IntentParserAgent.test.ts\n│   │   ├── QueryBuilderAgent.test.ts\n│   │   └── ValidationAgent.test.ts\n│   ├── components/\n│   │   ├── ChatInterface.test.tsx\n│   │   └── QueryOptionCard.test.tsx\n│   └── integration/\n│       └── end-to-end.test.ts\n└── docs/\n    ├── API.md\n    ├── DEPLOYMENT.md\n    └── TROUBLESHOOTING.md\n```\n\n### Configuration Files\n\n#### package.json\n```\n{\n  \"name\": \"elasticsearch-query-helper\",\n  \"version\": \"1.0.0\",\n  \"description\": \"AI-powered Elasticsearch query generation Chrome extension\",\n  \"scripts\": {\n    \"dev\": \"vite build --watch --mode development\",\n    \"build\": \"vite build --mode production\",\n    \"test\": \"jest\",\n    \"test:watch\": \"jest --watch\",\n    \"lint\": \"eslint src/**/*.{ts,tsx}\",\n    \"type-check\": \"tsc --noEmit\",\n    \"package\": \"npm run build && zip -r elasticsearch-query-helper.zip dist manifest.json\",\n    \"clean\": \"rm -rf dist && rm -f *.zip\"\n  },\n  \"dependencies\": {\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\",\n    \"lucide-react\": \"^0.294.0\",\n    \"class-variance-authority\": \"^0.7.0\",\n    \"clsx\": \"^2.0.0\",\n    \"tailwind-merge\": \"^2.0.0\"\n  },\n  \"devDependencies\": {\n    \"@types/chrome\": \"^0.0.254\",\n    \"@types/react\": \"^18.2.0\",\n    \"@types/react-dom\": \"^18.2.0\",\n    \"@types/jest\": \"^29.5.0\",\n    \"@testing-library/react\": \"^13.4.0\",\n    \"@testing-library/jest-dom\": \"^6.0.0\",\n    \"typescript\": \"^5.0.0\",\n    \"vite\": \"^5.0.0\",\n    \"@vitejs/plugin-react\": \"^4.0.0\",\n    \"tailwindcss\": \"^3.3.0\",\n    \"postcss\": \"^8.4.0\",\n    \"autoprefixer\": \"^10.4.0\",\n    \"eslint\": \"^8.0.0\",\n    \"@typescript-eslint/eslint-plugin\": \"^6.0.0\",\n    \"@typescript-eslint/parser\": \"^6.0.0\",\n    \"jest\": \"^29.5.0\",\n    \"ts-jest\": \"^29.1.0\"\n  }\n}\n```\n\n#### manifest.json\n```\n{\n  \"manifest_version\": 3,\n  \"name\": \"Elasticsearch Query Helper AI\",\n  \"version\": \"1.0.0\",\n  \"description\": \"AI-powered Elasticsearch query generation with multi-agent intelligence\",\n  \"permissions\": [\n    \"storage\",\n    \"sidePanel\"\n  ],\n  \"host_permissions\": [\n    \"https://generativelanguage.googleapis.com/*\",\n    \"https://api.openai.com/*\",\n    \"https://api.anthropic.com/*\",\n    \"http://localhost:*\"\n  ],\n  \"background\": {\n    \"service_worker\": \"background.js\",\n    \"type\": \"module\"\n  },\n  \"side_panel\": {\n    \"default_path\": \"sidepanel.html\"\n  },\n  \"action\": {\n    \"default_title\": \"Open Elasticsearch Query Helper\",\n    \"default_popup\": \"\"\n  },\n  \"content_security_policy\": {\n    \"extension_pages\": \"script-src 'self'; object-src 'self'; connect-src https://generativelanguage.googleapis.com https://api.openai.com https://api.anthropic.com http://localhost:*\"\n  },\n  \"icons\": {\n    \"16\": \"icons/icon16.png\",\n    \"48\": \"icons/icon48.png\",\n    \"128\": \"icons/icon128.png\"\n  }\n}\n```\n\n#### tsconfig.json\n```\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"],\n    \"module\": \"ESNext\",\n    \"skipLibCheck\": true,\n    \"moduleResolution\": \"bundler\",\n    \"allowImportingTsExtensions\": true,\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"noEmit\": true,\n    \"jsx\": \"react-jsx\",\n    \"strict\": true,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"types\": [\"chrome\", \"jest\", \"@testing-library/jest-dom\"]\n  },\n  \"include\": [\"src\", \"tests\"],\n  \"references\": [{ \"path\": \"./tsconfig.node.json\" }]\n}\n```\n\n#### vite.config.ts\n```\nimport { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\nimport { resolve } from 'path'\n\nexport default defineConfig({\n  plugins: [react()],\n  build: {\n    outDir: 'dist',\n    rollupOptions: {\n      input: {\n        background: resolve(__dirname, 'src/background/background.ts'),\n        sidepanel: resolve(__dirname, 'src/sidepanel/index.html')\n      },\n      output: {\n        entryFileNames: '[name].js',\n        chunkFileNames: '[name].js',\n        assetFileNames: '[name].[ext]'\n      }\n    }\n  },\n  define: {\n    'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV)\n  }\n})\n```\n\n---\n\n## TypeScript Interfaces and Types\n\n### src/shared/types/agents.ts\n```\nexport interface ParsedIntent {\n  entities: {\n    companies: string[];\n    locations: string[];\n    skills: string[];\n    jobTitles: string[];\n    dateRanges: DateRange[];\n    salaryRanges: SalaryRange[];\n  };\n  analysisType: 'search' | 'aggregation' | 'analytics';\n  complexity: 'simple' | 'medium' | 'complex';\n  confidence: number;\n  rawInput: string;\n}\n\nexport interface DateRange {\n  gte?: string;\n  lte?: string;\n  gt?: string;\n  lt?: string;\n}\n\nexport interface SalaryRange {\n  min?: number;\n  max?: number;\n  currency?: string;\n}\n\nexport interface QueryPerspective {\n  id: string;\n  name: string;\n  description: string;\n  approach: 'exact_match' | 'fuzzy_search' | 'analytics' | 'trend_analysis';\n  reasoning: string;\n  confidence: number;\n  estimatedComplexity: number;\n}\n\nexport interface QueryResult {\n  query: ESQuery;\n  perspective: QueryPerspective;\n  validation: ValidationResult;\n  reasoning: string;\n  complexity: number;\n  estimatedPerformance: PerformanceMetrics;\n  agentLogs: AgentLog[];\n}\n\nexport interface ValidationResult {\n  isValid: boolean;\n  syntaxErrors: string[];\n  schemaErrors: string[];\n  performanceWarnings: string[];\n  securityIssues: string[];\n  score: number;\n  recommendations: string[];\n}\n\nexport interface PerformanceMetrics {\n  executionTime?: number;\n  memoryUsage?: number;\n  complexityScore: number;\n  optimizationSuggestions: string[];\n}\n\nexport interface AgentLog {\n  timestamp: Date;\n  agent: string;\n  action: string;\n  input: any;\n  output: any;\n  duration: number;\n  success: boolean;\n  error?: string;\n}\n\nexport interface AgentContext {\n  userInput: string;\n  parsedIntent?: ParsedIntent;\n  schema: ElasticsearchSchema;\n  sampleQueries: SampleQuery[];\n  config: LLMConfiguration;\n  debugMode: boolean;\n  sessionId: string;\n}\n```\n\n### src/shared/types/elasticsearch.ts\n```\nexport interface ESQuery {\n  query: any;\n  size?: number;\n  from?: number;\n  _source?: string[] | boolean;\n  aggs?: any;\n  sort?: any[];\n  track_total_hits?: boolean;\n  timeout?: string;\n}\n\nexport interface ElasticsearchSchema {\n  mappings: {\n    properties: Record;\n  };\n  version: string;\n  lastUpdated: Date;\n  indexName: string;\n}\n\nexport interface FieldMapping {\n  type: 'text' | 'keyword' | 'long' | 'integer' | 'date' | 'boolean' | 'geo_point' | 'nested' | 'object';\n  fields?: Record;\n  properties?: Record;\n  analyzer?: string;\n  format?: string;\n}\n\nexport interface SampleQuery {\n  id: string;\n  description: string;\n  userIntent: string;\n  query: ESQuery;\n  tags: string[];\n  complexity: 'simple' | 'medium' | 'complex';\n  successRate: number;\n  businessContext?: string;\n  performanceNotes?: string;\n}\n```\n\n### src/shared/types/llm.ts\n```\nexport interface LLMConfiguration {\n  provider: 'gemini' | 'openai' | 'anthropic' | 'ollama';\n  apiKey?: string;\n  baseUrl?: string;\n  model: string;\n  temperature: number;\n  maxTokens: number;\n  timeout: number;\n  retryAttempts: number;\n}\n\nexport interface LLMProvider {\n  id: string;\n  name: string;\n  models: string[];\n  apiEndpoint: string;\n  authType: 'api_key' | 'bearer_token' | 'none';\n  defaultConfig: Partial;\n  rateLimits: {\n    requestsPerMinute: number;\n    tokensPerMinute: number;\n  };\n  supportedFeatures: string[];\n}\n\nexport interface LLMResponse {\n  content: string;\n  usage?: {\n    promptTokens: number;\n    completionTokens: number;\n    totalTokens: number;\n  };\n  model: string;\n  finishReason: string;\n}\n```\n\n### src/shared/types/ui.ts\n```\nexport interface ChatMessage {\n  id: string;\n  type: 'user' | 'assistant' | 'error' | 'debug' | 'system';\n  content: string;\n  timestamp: Date;\n  queryResults?: QueryResult[];\n  metadata?: Record;\n}\n\nexport interface UIState {\n  isLoading: boolean;\n  currentQuery: string;\n  messages: ChatMessage[];\n  selectedProvider: string;\n  debugMode: boolean;\n  settingsOpen: boolean;\n  theme: 'light' | 'dark';\n}\n\nexport interface DebugInfo {\n  agentLogs: AgentLog[];\n  performanceMetrics: PerformanceMetrics;\n  cacheHits: Record;\n  errorDetails?: string;\n}\n```\n\n---\n\n## Core Implementation Files\n\n### src/background/services/LLMClient.ts\n```\nimport { LLMConfiguration, LLMProvider, LLMResponse } from '../../shared/types/llm';\nimport { LLM_PROVIDERS } from '../../shared/config/llm-providers';\n\nexport class LLMClient {\n  private config: LLMConfiguration;\n  private provider: LLMProvider;\n\n  constructor(config: LLMConfiguration) {\n    this.config = config;\n    this.provider = LLM_PROVIDERS[config.provider];\n    \n    if (!this.provider) {\n      throw new Error(`Unsupported LLM provider: ${config.provider}`);\n    }\n  }\n\n  async generateCompletion(prompt: string, systemPrompt?: string): Promise {\n    const startTime = Date.now();\n    \n    try {\n      let response: LLMResponse;\n      \n      switch (this.config.provider) {\n        case 'gemini':\n          response = await this.callGeminiAPI(prompt, systemPrompt);\n          break;\n        case 'openai':\n          response = await this.callOpenAIAPI(prompt, systemPrompt);\n          break;\n        case 'anthropic':\n          response = await this.callAnthropicAPI(prompt, systemPrompt);\n          break;\n        case 'ollama':\n          response = await this.callOllamaAPI(prompt, systemPrompt);\n          break;\n        default:\n          throw new Error(`Provider ${this.config.provider} not implemented`);\n      }\n      \n      console.log(`LLM call completed in ${Date.now() - startTime}ms`);\n      return response.content;\n      \n    } catch (error) {\n      console.error('LLM call failed:', error);\n      throw new Error(`LLM API error: ${error.message}`);\n    }\n  }\n\n  private async callGeminiAPI(prompt: string, systemPrompt?: string): Promise {\n    const url = `${this.provider.apiEndpoint}/models/${this.config.model}:generateContent?key=${this.config.apiKey}`;\n    \n    const body = {\n      contents: [{\n        parts: [{\n          text: systemPrompt ? `${systemPrompt}\\n\\nUser: ${prompt}` : prompt\n        }]\n      }],\n      generationConfig: {\n        temperature: this.config.temperature,\n        maxOutputTokens: this.config.maxTokens\n      }\n    };\n\n    const response = await this.makeRequest(url, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(body)\n    });\n\n    if (!response.ok) {\n      throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);\n    }\n\n    const data = await response.json();\n    \n    if (!data.candidates || !data.candidates || !data.candidates.content) {\n      throw new Error('Invalid response format from Gemini API');\n    }\n\n    return {\n      content: data.candidates.content.parts.text,\n      model: this.config.model,\n      finishReason: data.candidates.finishReason || 'stop'\n    };\n  }\n\n  private async callOpenAIAPI(prompt: string, systemPrompt?: string): Promise {\n    const url = `${this.provider.apiEndpoint}/chat/completions`;\n    \n    const messages = [];\n    if (systemPrompt) {\n      messages.push({ role: 'system', content: systemPrompt });\n    }\n    messages.push({ role: 'user', content: prompt });\n\n    const body = {\n      model: this.config.model,\n      messages,\n      temperature: this.config.temperature,\n      max_tokens: this.config.maxTokens\n    };\n\n    const response = await this.makeRequest(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${this.config.apiKey}`\n      },\n      body: JSON.stringify(body)\n    });\n\n    if (!response.ok) {\n      throw new Error(`OpenAI API error: ${response.status} ${response.statusText}`);\n    }\n\n    const data = await response.json();\n    \n    return {\n      content: data.choices.message.content,\n      usage: data.usage,\n      model: data.model,\n      finishReason: data.choices.finish_reason\n    };\n  }\n\n  private async callAnthropicAPI(prompt: string, systemPrompt?: string): Promise {\n    const url = `${this.provider.apiEndpoint}/messages`;\n    \n    const body = {\n      model: this.config.model,\n      max_tokens: this.config.maxTokens,\n      temperature: this.config.temperature,\n      system: systemPrompt,\n      messages: [{ role: 'user', content: prompt }]\n    };\n\n    const response = await this.makeRequest(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'x-api-key': this.config.apiKey,\n        'anthropic-version': '2023-06-01'\n      },\n      body: JSON.stringify(body)\n    });\n\n    if (!response.ok) {\n      throw new Error(`Anthropic API error: ${response.status} ${response.statusText}`);\n    }\n\n    const data = await response.json();\n    \n    return {\n      content: data.content.text,\n      usage: data.usage,\n      model: data.model,\n      finishReason: data.stop_reason\n    };\n  }\n\n  private async callOllamaAPI(prompt: string, systemPrompt?: string): Promise {\n    const url = `${this.config.baseUrl || 'http://localhost:11434'}/api/generate`;\n    \n    const body = {\n      model: this.config.model,\n      prompt: systemPrompt ? `${systemPrompt}\\n\\nUser: ${prompt}` : prompt,\n      stream: false,\n      options: {\n        temperature: this.config.temperature,\n        num_predict: this.config.maxTokens\n      }\n    };\n\n    const response = await this.makeRequest(url, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(body)\n    });\n\n    if (!response.ok) {\n      throw new Error(`Ollama API error: ${response.status} ${response.statusText}`);\n    }\n\n    const data = await response.json();\n    \n    return {\n      content: data.response,\n      model: data.model,\n      finishReason: data.done ? 'stop' : 'length'\n    };\n  }\n\n  private async makeRequest(url: string, options: RequestInit): Promise {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);\n    \n    try {\n      const response = await fetch(url, {\n        ...options,\n        signal: controller.signal\n      });\n      return response;\n    } finally {\n      clearTimeout(timeoutId);\n    }\n  }\n\n  async testConnection(): Promise {\n    try {\n      await this.generateCompletion('Test connection', 'Respond with \"OK\"');\n      return true;\n    } catch (error) {\n      console.error('Connection test failed:', error);\n      return false;\n    }\n  }\n}\n```\n\n### src/background/agents/IntentParserAgent.ts\n```\nimport { LLMClient } from '../services/LLMClient';\nimport { ParsedIntent, AgentContext, AgentLog } from '../../shared/types/agents';\n\nexport class IntentParserAgent {\n  private llmClient: LLMClient;\n\n  constructor(llmClient: LLMClient) {\n    this.llmClient = llmClient;\n  }\n\n  async parse(userInput: string, context: AgentContext): Promise {\n    const startTime = Date.now();\n    const log: AgentLog = {\n      timestamp: new Date(),\n      agent: 'IntentParser',\n      action: 'parse',\n      input: { userInput },\n      output: null,\n      duration: 0,\n      success: false\n    };\n\n    try {\n      const systemPrompt = this.buildSystemPrompt(context);\n      const userPrompt = this.buildUserPrompt(userInput, context.sampleQueries);\n      \n      const response = await this.llmClient.generateCompletion(userPrompt, systemPrompt);\n      \n      const parsed = JSON.parse(response);\n      const validated = this.validateAndNormalize(parsed, userInput);\n      \n      log.output = validated;\n      log.success = true;\n      log.duration = Date.now() - startTime;\n      \n      if (context.debugMode) {\n        context.agentLogs?.push(log);\n      }\n      \n      return validated;\n      \n    } catch (error) {\n      log.error = error.message;\n      log.duration = Date.now() - startTime;\n      \n      if (context.debugMode) {\n        context.agentLogs?.push(log);\n      }\n      \n      throw new Error(`Intent parsing failed: ${error.message}`);\n    }\n  }\n\n  private buildSystemPrompt(context: AgentContext): string {\n    return `You are an expert Elasticsearch intent parser for a jobs index.\n\nJOBS INDEX SCHEMA:\n${JSON.stringify(context.schema.mappings.properties, null, 2)}\n\nYour task is to extract structured information from user queries and return JSON in this exact format:\n{\n  \"entities\": {\n    \"companies\": [\"extracted company names\"],\n    \"locations\": [\"extracted locations\"],\n    \"skills\": [\"extracted skills/technologies\"],\n    \"jobTitles\": [\"extracted job titles\"],\n    \"dateRanges\": [{\"gte\": \"date\", \"lte\": \"date\"}],\n    \"salaryRanges\": [{\"min\": number, \"max\": number}]\n  },\n  \"analysisType\": \"search|aggregation|analytics\",\n  \"complexity\": \"simple|medium|complex\",\n  \"confidence\": 0.95\n}\n\nEXTRACTION RULES:\n- Extract only entities that can be mapped to schema fields\n- Normalize company names to common formats (Google vs Alphabet Inc.)\n- Convert location references to standardized forms\n- Identify programming languages, frameworks, and technical skills\n- Parse relative dates (e.g., \"last 30 days\" → specific date range using now-30d format)\n- Extract salary information when mentioned\n- Classify complexity: simple (1-2 criteria), medium (3-4 criteria), complex (5+ criteria or aggregations)\n- Set confidence based on clarity of user intent\n\nRESPONSE: Return only valid JSON, no explanations.`;\n  }\n\n  private buildUserPrompt(userInput: string, sampleQueries: any[]): string {\n    const relevantExamples = this.findRelevantExamples(userInput, sampleQueries, 3);\n    \n    return `USER QUERY: \"${userInput}\"\n\nRELEVANT EXAMPLE PATTERNS:\n${relevantExamples.map(ex => `\n- Intent: ${ex.userIntent}\n- Entities found: ${ex.tags.join(', ')}\n- Complexity: ${ex.complexity}\n`).join('\\n')}\n\nExtract structured intent from the user query:`;\n  }\n\n  private findRelevantExamples(userInput: string, samples: any[], limit: number): any[] {\n    const keywords = userInput.toLowerCase().split(/\\s+/);\n    \n    const scored = samples.map(sample => {\n      const sampleText = `${sample.description} ${sample.userIntent} ${sample.tags.join(' ')}`.toLowerCase();\n      \n      const score = keywords.reduce((acc, keyword) => {\n        return acc + (sampleText.includes(keyword) ? 1 : 0);\n      }, 0);\n      \n      return { sample, score };\n    });\n    \n    return scored\n      .sort((a, b) => b.score - a.score)\n      .slice(0, limit)\n      .map(item => item.sample);\n  }\n\n  private validateAndNormalize(parsed: any, originalInput: string): ParsedIntent {\n    // Input validation and normalization\n    const normalized: ParsedIntent = {\n      entities: {\n        companies: Array.isArray(parsed.entities?.companies) ? parsed.entities.companies : [],\n        locations: Array.isArray(parsed.entities?.locations) ? parsed.entities.locations : [],\n        skills: Array.isArray(parsed.entities?.skills) ? parsed.entities.skills : [],\n        jobTitles: Array.isArray(parsed.entities?.jobTitles) ? parsed.entities.jobTitles : [],\n        dateRanges: Array.isArray(parsed.entities?.dateRanges) ? parsed.entities.dateRanges : [],\n        salaryRanges: Array.isArray(parsed.entities?.salaryRanges) ? parsed.entities.salaryRanges : []\n      },\n      analysisType: ['search', 'aggregation', 'analytics'].includes(parsed.analysisType) \n        ? parsed.analysisType : 'search',\n      complexity: ['simple', 'medium', 'complex'].includes(parsed.complexity) \n        ? parsed.complexity : 'simple',\n      confidence: typeof parsed.confidence === 'number' \n        ? Math.max(0, Math.min(1, parsed.confidence)) : 0.5,\n      rawInput: originalInput\n    };\n\n    // Additional normalization\n    normalized.entities.companies = normalized.entities.companies.map(this.normalizeCompanyName);\n    normalized.entities.skills = normalized.entities.skills.map(this.normalizeSkillName);\n\n    return normalized;\n  }\n\n  private normalizeCompanyName(company: string): string {\n    const normalizations: Record = {\n      'alphabet': 'Alphabet Inc.',\n      'google': 'Google',\n      'microsoft': 'Microsoft',\n      'apple': 'Apple Inc.',\n      'amazon': 'Amazon',\n      'meta': 'Meta',\n      'facebook': 'Meta'\n    };\n    \n    return normalizations[company.toLowerCase()] || company;\n  }\n\n  private normalizeSkillName(skill: string): string {\n    const normalizations: Record = {\n      'js': 'JavaScript',\n      'ts': 'TypeScript',\n      'py': 'Python',\n      'nodejs': 'Node.js',\n      'reactjs': 'React'\n    };\n    \n    return normalizations[skill.toLowerCase()] || skill;\n  }\n}\n```\n\n### src/background/agents/QueryBuilderAgent.ts\n```\nimport { LLMClient } from '../services/LLMClient';\nimport { ParsedIntent, QueryPerspective, AgentContext, ESQuery, AgentLog } from '../../shared/types/agents';\n\nexport class QueryBuilderAgent {\n  private llmClient: LLMClient;\n\n  constructor(llmClient: LLMClient) {\n    this.llmClient = llmClient;\n  }\n\n  async buildQuery(\n    intent: ParsedIntent, \n    perspective: QueryPerspective, \n    context: AgentContext\n  ): Promise {\n    const startTime = Date.now();\n    const log: AgentLog = {\n      timestamp: new Date(),\n      agent: 'QueryBuilder',\n      action: 'buildQuery',\n      input: { intent, perspective },\n      output: null,\n      duration: 0,\n      success: false\n    };\n\n    try {\n      const systemPrompt = this.buildSystemPrompt(context);\n      const userPrompt = this.buildUserPrompt(intent, perspective, context.sampleQueries);\n      \n      const response = await this.llmClient.generateCompletion(userPrompt, systemPrompt);\n      \n      let query: ESQuery;\n      try {\n        query = JSON.parse(response);\n      } catch (parseError) {\n        // Try to extract JSON from response if it contains additional text\n        const jsonMatch = response.match(/\\{[\\s\\S]*\\}/);\n        if (jsonMatch) {\n          query = JSON.parse(jsonMatch);\n        } else {\n          throw new Error('Invalid JSON in LLM response');\n        }\n      }\n      \n      const enhancedQuery = this.enforceStandardFilters(query);\n      const optimizedQuery = this.optimizeQuery(enhancedQuery, intent);\n      \n      log.output = optimizedQuery;\n      log.success = true;\n      log.duration = Date.now() - startTime;\n      \n      if (context.debugMode) {\n        context.agentLogs?.push(log);\n      }\n      \n      return optimizedQuery;\n      \n    } catch (error) {\n      log.error = error.message;\n      log.duration = Date.now() - startTime;\n      \n      if (context.debugMode) {\n        context.agentLogs?.push(log);\n      }\n      \n      throw new Error(`Query building failed: ${error.message}`);\n    }\n  }\n\n  private buildSystemPrompt(context: AgentContext): string {\n    return `You are an expert Elasticsearch Query Builder for jobs data.\n\nJOBS INDEX SCHEMA:\n${JSON.stringify(context.schema.mappings.properties, null, 2)}\n\nMANDATORY REQUIREMENTS:\n1. Always include: {\"term\": {\"is_deleted.keyword\": \"0\"}}\n2. Always include: {\"term\": {\"is_duplicate\": false}} \n3. Use .keyword fields for exact matching and aggregations\n4. Use analyzed fields for full-text search\n5. Prefer filters over queries for performance\n6. Include appropriate date range filters\n\nFIELD USAGE PATTERNS:\n- job_title: Use both analyzed and .keyword versions\n- company_name: Prefer .keyword for exact matches, analyzed for fuzzy\n- location: Use analyzed for fuzzy matching, .keyword for exact\n- standardized_geo_point: For geo-distance queries\n- crawled_date/posted_date: For time-based filtering\n- job_description: For skills and requirements matching\n- raw_salary: For salary-based filtering\n- skills.name: For technical skills matching\n\nQUERY OPTIMIZATION:\n- Use term queries for exact matches\n- Use match queries for full-text search\n- Use filters in bool context when possible\n- Combine must/should/filter appropriately\n- Limit aggregation sizes to reasonable values\n- Use _source filtering to reduce payload size\n\nRESPONSE FORMAT:\nReturn only valid Elasticsearch 7.x JSON query. No explanations or additional text.\n\nPERFORMANCE CONSIDERATIONS:\n- Avoid script queries\n- Limit wildcard usage\n- Use appropriate field types (.keyword vs analyzed)\n- Set reasonable size limits\n- Include timeout parameters for complex queries`;\n  }\n\n  private buildUserPrompt(\n    intent: ParsedIntent, \n    perspective: QueryPerspective, \n    samples: any[]\n  ): string {\n    const relevantQueries = this.findSimilarQueries(intent, perspective, samples, 3);\n    \n    return `BUILD ELASTICSEARCH QUERY:\n\nUSER INTENT:\n${JSON.stringify(intent, null, 2)}\n\nPERSPECTIVE: ${perspective.name}\nApproach: ${perspective.approach}\nDescription: ${perspective.description}\nReasoning: ${perspective.reasoning}\n\nSIMILAR SUCCESSFUL QUERIES:\n${relevantQueries.map(q => `\nExample: ${q.description}\nIntent: ${q.userIntent}\nQuery Structure:\n${JSON.stringify(q.query, null, 2)}\nPerformance Notes: ${q.performanceNotes || 'Good performance'}\n`).join('\\n')}\n\nGenerate the optimized Elasticsearch query based on the intent and perspective:`;\n  }\n\n  private findSimilarQueries(\n    intent: ParsedIntent, \n    perspective: QueryPerspective, \n    samples: any[], \n    limit: number\n  ): any[] {\n    const scored = samples.map(sample => {\n      let score = 0;\n      \n      // Entity-based scoring\n      if (intent.entities.companies.length > 0 && sample.tags.includes('company')) score += 3;\n      if (intent.entities.locations.length > 0 && sample.tags.includes('location')) score += 3;\n      if (intent.entities.skills.length > 0 && sample.tags.includes('skills')) score += 3;\n      if (intent.entities.jobTitles.length > 0 && sample.tags.includes('job_title')) score += 3;\n      if (intent.entities.dateRanges.length > 0 && sample.tags.includes('date_range')) score += 2;\n      if (intent.entities.salaryRanges.length > 0 && sample.tags.includes('salary')) score += 2;\n      \n      // Analysis type scoring\n      if (intent.analysisType === 'aggregation' && sample.tags.includes('aggregation')) score += 5;\n      if (intent.analysisType === 'search' && sample.tags.includes('search')) score += 2;\n      if (intent.analysisType === 'analytics' && sample.tags.includes('analytics')) score += 4;\n      \n      // Complexity matching\n      if (intent.complexity === sample.complexity) score += 2;\n      \n      // Perspective approach alignment\n      if (perspective.approach === 'exact_match' && sample.tags.includes('exact_match')) score += 3;\n      if (perspective.approach === 'fuzzy_search' && sample.tags.includes('fuzzy')) score += 3;\n      if (perspective.approach === 'analytics' && sample.tags.includes('aggregation')) score += 3;\n      \n      return { sample, score };\n    });\n    \n    return scored\n      .sort((a, b) => b.score - a.score)\n      .slice(0, limit)\n      .map(item => item.sample);\n  }\n\n  private enforceStandardFilters(query: ESQuery): ESQuery {\n    // Ensure mandatory filters are always present\n    if (!query.query) {\n      query.query = { match_all: {} };\n    }\n    \n    // Initialize bool query structure\n    let boolQuery = {\n      bool: {\n        must: [] as any[],\n        filter: [\n          { term: { 'is_deleted.keyword': '0' } },\n          { term: { 'is_duplicate': false } }\n        ] as any[],\n        should: [] as any[],\n        must_not: [] as any[]\n      }\n    };\n\n    // Merge existing query structure\n    if (query.query.bool) {\n      boolQuery.bool.must = query.query.bool.must || [];\n      boolQuery.bool.should = query.query.bool.should || [];\n      boolQuery.bool.must_not = query.query.bool.must_not || [];\n      \n      // Merge filters, avoiding duplicates\n      const existingFilters = query.query.bool.filter || [];\n      const mandatoryFilters = boolQuery.bool.filter;\n      \n      boolQuery.bool.filter = [\n        ...mandatoryFilters,\n        ...existingFilters.filter(f => \n          !mandatoryFilters.some(mf => JSON.stringify(mf) === JSON.stringify(f))\n        )\n      ];\n      \n      // Copy other bool properties\n      if (query.query.bool.minimum_should_match !== undefined) {\n        boolQuery.bool.minimum_should_match = query.query.bool.minimum_should_match;\n      }\n    } else {\n      // Wrap non-bool query in must clause\n      boolQuery.bool.must.push(query.query);\n    }\n\n    return {\n      ...query,\n      query: boolQuery\n    };\n  }\n\n  private optimizeQuery(query: ESQuery, intent: ParsedIntent): ESQuery {\n    // Add default optimizations\n    const optimized = { ...query };\n    \n    // Set reasonable defaults if not specified\n    if (!optimized.size && intent.analysisType !== 'aggregation') {\n      optimized.size = 50; // Default result size\n    }\n    \n    // Add timeout for complex queries\n    if (intent.complexity === 'complex' && !optimized.timeout) {\n      optimized.timeout = '30s';\n    }\n    \n    // Optimize source fields for performance\n    if (!optimized._source && intent.analysisType === 'search') {\n      optimized._source = [\n        'job_title',\n        'company_name',\n        'location',\n        'standardized_location',\n        'raw_salary',\n        'posted_date',\n        'url'\n      ];\n    }\n    \n    // Add track_total_hits for aggregations\n    if (intent.analysisType === 'aggregation') {\n      optimized.track_total_hits = true;\n      optimized.size = 0; // Don't return documents for pure aggregations\n    }\n    \n    return optimized;\n  }\n}\n```\n\n### src/sidepanel/components/ChatInterface.tsx\n```\nimport React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { ChatMessage, QueryResult } from '../../shared/types/ui';\nimport { QueryOptionCard } from './QueryOptionCard';\nimport { LoadingSpinner } from './LoadingSpinner';\nimport { Send, RotateCcw } from 'lucide-react';\n\ninterface ChatInterfaceProps {\n  onQuerySubmit: (query: string) => Promise;\n  debugMode: boolean;\n  isConnected: boolean;\n}\n\nexport const ChatInterface: React.FC = ({ \n  onQuerySubmit, \n  debugMode,\n  isConnected \n}) => {\n  const [messages, setMessages] = useState([]);\n  const [inputValue, setInputValue] = useState('');\n  const [isLoading, setIsLoading] = useState(false);\n  const messagesEndRef = useRef(null);\n  const inputRef = useRef(null);\n\n  const scrollToBottom = useCallback(() => {\n    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n  }, []);\n\n  useEffect(() => {\n    scrollToBottom();\n  }, [messages, scrollToBottom]);\n\n  useEffect(() => {\n    // Focus input when component mounts\n    inputRef.current?.focus();\n  }, []);\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    if (!inputValue.trim() || isLoading || !isConnected) return;\n\n    const userMessage: ChatMessage = {\n      id: `user-${Date.now()}`,\n      type: 'user',\n      content: inputValue.trim(),\n      timestamp: new Date()\n    };\n\n    setMessages(prev => [...prev, userMessage]);\n    setInputValue('');\n    setIsLoading(true);\n\n    try {\n      const results = await onQuerySubmit(inputValue.trim());\n      \n      if (results && results.length > 0) {\n        const assistantMessage: ChatMessage = {\n          id: `assistant-${Date.now()}`,\n          type: 'assistant',\n          content: `Generated ${results.length} query option${results.length > 1 ? 's' : ''}:`,\n          timestamp: new Date(),\n          queryResults: results\n        };\n        \n        setMessages(prev => [...prev, assistantMessage]);\n      } else {\n        const errorMessage: ChatMessage = {\n          id: `error-${Date.now()}`,\n          type: 'error',\n          content: 'No valid queries could be generated. Please try rephrasing your request.',\n          timestamp: new Date()\n        };\n        \n        setMessages(prev => [...prev, errorMessage]);\n      }\n    } catch (error) {\n      console.error('Query generation error:', error);\n      \n      const errorMessage: ChatMessage = {\n        id: `error-${Date.now()}`,\n        type: 'error',\n        content: `Error: ${error.message || 'Failed to generate query. Please check your LLM configuration.'}`,\n        timestamp: new Date()\n      };\n      \n      setMessages(prev => [...prev, errorMessage]);\n    } finally {\n      setIsLoading(false);\n      inputRef.current?.focus();\n    }\n  };\n\n  const clearMessages = () => {\n    setMessages([]);\n  };\n\n  const exampleQueries = [\n    \"Find software engineer jobs in San Francisco\",\n    \"Show me remote jobs requiring Python\",\n    \"Jobs at Google or Microsoft posted last week\",\n    \"Count jobs by company in Germany\"\n  ];\n\n  const handleExampleClick = (example: string) => {\n    setInputValue(example);\n    inputRef.current?.focus();\n  };\n\n  return (\n    \n      {/* Header */}\n      \n        \n          Elasticsearch Query Helper\n        \n        \n          \n          \n            {isConnected ? 'Connected' : 'Disconnected'}\n          \n          {messages.length > 0 && (\n            \n              \n            \n          )}\n        \n      \n      \n      {/* Messages Area */}\n      \n        {messages.length === 0 && (\n          \n            \n              Welcome to Elasticsearch Query Helper\n            \n            \n              Describe what you're looking for and I'll generate the perfect Elasticsearch query.\n            \n            \n              Try these examples:\n              {exampleQueries.map((example, index) => (\n                 handleExampleClick(example)}\n                  className=\"block w-full text-left p-3 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-600 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700 text-sm\"\n                >\n                  {example}\n                \n              ))}\n            \n          \n        )}\n        \n        {messages.map(message => (\n          \n        ))}\n        \n        {isLoading && (\n          \n            \n            Processing your request...\n          \n        )}\n        \n        \n      \n      \n      {/* Input Form */}\n      \n        \n           setInputValue(e.target.value)}\n            placeholder={isConnected ? \"Describe what you're looking for...\" : \"Configure LLM provider in settings first\"}\n            className=\"flex-1 p-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white dark:bg-gray-700 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400\"\n            disabled={isLoading || !isConnected}\n            maxLength={500}\n          />\n          \n            \n          \n        \n        {inputValue.length > 400 && (\n          \n            {500 - inputValue.length} characters remaining\n          \n        )}\n      \n    \n  );\n};\n\nconst MessageBubble: React.FC = ({ message, debugMode }) => {\n  const isUser = message.type === 'user';\n  const isError = message.type === 'error';\n  const isSystem = message.type === 'system';\n  \n  return (\n    \n      \n        {message.content}\n        \n        {message.queryResults && message.queryResults.length > 0 && (\n          \n            {message.queryResults.map((result, index) => (\n              \n            ))}\n          \n        )}\n        \n        \n          {message.timestamp.toLocaleTimeString()}\n        \n      \n    \n  );\n};\n```\n\n### src/data/sample-queries.json\n```\n{\n  \"sampleQueries\": [\n    {\n      \"id\": \"basic_source_search\",\n      \"description\": \"Find jobs from specific job board with recent crawl date\",\n      \"userIntent\": \"source-based filtering with time constraint\",\n      \"query\": {\n        \"query\": {\n          \"bool\": {\n            \"must\": [\n              {\"match\": {\"source_name.keyword\": \"Indeed_US\"}},\n              {\"term\": {\"is_deleted.keyword\": \"0\"}}\n            ],\n            \"filter\": [\n              {\"range\": {\"crawled_date\": {\"gte\": \"now-7d/d\", \"lte\": \"now\"}}}\n            ]\n          }\n        },\n        \"size\": 50\n      },\n      \"tags\": [\"source_filter\", \"date_range\", \"basic_search\"],\n      \"complexity\": \"simple\",\n      \"successRate\": 95,\n      \"performanceNotes\": \"Fast execution with indexed fields\"\n    },\n    {\n      \"id\": \"geo_proximity_search\",\n      \"description\": \"Find jobs within 50km of Frankfurt\",\n      \"userIntent\": \"location-based proximity search\",\n      \"query\": {\n        \"query\": {\n          \"bool\": {\n            \"must\": [\n              {\"term\": {\"is_deleted.keyword\": \"0\"}},\n              {\"term\": {\"is_duplicate\": false}}\n            ],\n            \"filter\": [\n              {\n                \"geo_distance\": {\n                  \"distance\": \"50km\",\n                  \"standardized_geo_point\": {\n                    \"lat\": 50.1109,\n                    \"lon\": 8.6821\n                  }\n                }\n              },\n              {\"range\": {\"crawled_date\": {\"gte\": \"now-30d/d\"}}}\n            ]\n          }\n        }\n      },\n      \"tags\": [\"geo_search\", \"location\", \"proximity\"],\n      \"complexity\": \"medium\",\n      \"successRate\": 88,\n      \"performanceNotes\": \"Requires geo-enabled fields\"\n    },\n    {\n      \"id\": \"skills_match_search\",\n      \"description\": \"Find software engineering jobs requiring Python and machine learning\",\n      \"userIntent\": \"skills and title matching\",\n      \"query\": {\n        \"query\": {\n          \"bool\": {\n            \"must\": [\n              {\"match\": {\"job_title\": \"software engineer\"}},\n              {\"match\": {\"job_description\": \"Python\"}},\n              {\"match\": {\"job_description\": \"machine learning\"}},\n              {\"term\": {\"is_deleted.keyword\": \"0\"}}\n            ],\n            \"filter\": [\n              {\"range\": {\"crawled_date\": {\"gte\": \"now-14d/d\"}}}\n            ]\n          }\n        }\n      },\n      \"tags\": [\"skills\", \"job_title\", \"technology\"],\n      \"complexity\": \"medium\",\n      \"successRate\": 92,\n      \"performanceNotes\": \"Good performance with proper field analysis\"\n    },\n    {\n      \"id\": \"company_filter_search\",\n      \"description\": \"Find all jobs at Google or Microsoft\",\n      \"userIntent\": \"company-specific job search\",\n      \"query\": {\n        \"query\": {\n          \"bool\": {\n            \"must\": [\n              {\n                \"terms\": {\n                  \"company_name.keyword\": [\"Google\", \"Microsoft\", \"Alphabet Inc.\"]\n                }\n              },\n              {\"term\": {\"is_deleted.keyword\": \"0\"}}\n            ],\n            \"filter\": [\n              {\"range\": {\"crawled_date\": {\"gte\": \"now-30d/d\"}}}\n            ]\n          }\n        }\n      },\n      \"tags\": [\"company\", \"multiple_values\", \"exact_match\"],\n      \"complexity\": \"simple\",\n      \"successRate\": 96,\n      \"performanceNotes\": \"Very fast with keyword fields\"\n    },\n    {\n      \"id\": \"salary_range_search\",\n      \"description\": \"Find jobs with salary information excluding N/A values\",\n      \"userIntent\": \"salary-based filtering\",\n      \"query\": {\n        \"query\": {\n          \"bool\": {\n            \"must\": [\n              {\"exists\": {\"field\": \"raw_salary\"}},\n              {\"term\": {\"is_deleted.keyword\": \"0\"}}\n            ],\n            \"must_not\": [\n              {\"match_phrase\": {\"raw_salary\": \"NA\"}},\n              {\"match_phrase\": {\"raw_salary\": \"#N/A\"}}\n            ],\n            \"filter\": [\n              {\"range\": {\"crawled_date\": {\"gte\": \"now-7d/d\"}}}\n            ]\n          }\n        }\n      },\n      \"tags\": [\"salary\", \"exists\", \"exclusion\"],\n      \"complexity\": \"medium\",\n      \"successRate\": 85,\n      \"performanceNotes\": \"Exists queries can be slower on large datasets\"\n    },\n    {\n      \"id\": \"date_range_field_selection\",\n      \"description\": \"Get specific fields for jobs posted in date range\",\n      \"userIntent\": \"targeted field retrieval with date filtering\",\n      \"query\": {\n        \"_source\": [\"job_title\", \"company_name\", \"location\", \"raw_salary\", \"url\"],\n        \"query\": {\n          \"bool\": {\n            \"must\": [\n              {\n                \"range\": {\n                  \"posted_date\": {\n                    \"gte\": \"2024-01-01\",\n                    \"lte\": \"2024-12-31\"\n                  }\n                }\n              },\n              {\"term\": {\"is_deleted.keyword\": \"0\"}}\n            ]\n          }\n        }\n      },\n      \"tags\": [\"field_selection\", \"date_range\", \"performance\"],\n      \"complexity\": \"simple\",\n      \"successRate\": 94,\n      \"performanceNotes\": \"Field selection improves network performance\"\n    },\n    {\n      \"id\": \"country_aggregation\",\n      \"description\": \"Count jobs by country code\",\n      \"userIntent\": \"statistical analysis by location\",\n      \"query\": {\n        \"size\": 0,\n        \"query\": {\n          \"bool\": {\n            \"must\": [\n              {\"term\": {\"is_deleted.keyword\": \"0\"}},\n              {\"range\": {\"crawled_date\": {\"gte\": \"now-30d/d\"}}}\n            ]\n          }\n        },\n        \"aggs\": {\n          \"jobs_by_country\": {\n            \"terms\": {\n              \"field\": \"country_code.keyword\",\n              \"size\": 50,\n              \"order\": {\"_count\": \"desc\"}\n            }\n          }\n        }\n      },\n      \"tags\": [\"aggregation\", \"statistics\", \"country\"],\n      \"complexity\": \"medium\",\n      \"successRate\": 91,\n      \"performanceNotes\": \"Aggregations benefit from size:0\"\n    },\n    {\n      \"id\": \"complex_multi_criteria\",\n      \"description\": \"Lufthansa cabin crew roles in German aviation hubs\",\n      \"userIntent\": \"complex business search with multiple location and title criteria\",\n      \"query\": {\n        \"query\": {\n          \"bool\": {\n            \"must\": [\n              {\n                \"bool\": {\n                  \"should\": [\n                    {\"wildcard\": {\"job_title.keyword\": \"*Crew*\"}},\n                    {\"wildcard\": {\"job_title.keyword\": \"*Cabin*\"}},\n                    {\"wildcard\": {\"job_title.keyword\": \"*Flight*\"}},\n                    {\"match\": {\"job_title\": \"scheduler\"}}\n                  ],\n                  \"minimum_should_match\": 1\n                }\n              },\n              {\"term\": {\"country_code.keyword\": \"DE\"}},\n              {\"term\": {\"is_deleted.keyword\": \"0\"}}\n            ],\n            \"should\": [\n              {\"match\": {\"company_name\": \"Lufthansa\"}},\n              {\"match\": {\"location\": \"Frankfurt\"}},\n              {\"match\": {\"location\": \"Munich\"}},\n              {\"match\": {\"location\": \"Hamburg\"}}\n            ],\n            \"filter\": [\n              {\"range\": {\"crawled_date\": {\"gte\": \"now-60d/d\"}}}\n            ]\n          }\n        }\n      },\n      \"tags\": [\"complex\", \"wildcard\", \"multiple_locations\", \"aviation\"],\n      \"complexity\": \"complex\",\n      \"successRate\": 78,\n      \"performanceNotes\": \"Wildcard queries can impact performance\"\n    },\n    {\n      \"id\": \"tech_stack_search\",\n      \"description\": \"Find developers with specific technology stack\",\n      \"userIntent\": \"technology-specific role matching\",\n      \"query\": {\n        \"query\": {\n          \"bool\": {\n            \"must\": [\n              {\"match\": {\"job_title\": \"developer\"}},\n              {\"match\": {\"job_description\": \"React\"}},\n              {\"match\": {\"job_description\": \"Node.js\"}},\n              {\"term\": {\"is_deleted.keyword\": \"0\"}}\n            ],\n            \"should\": [\n              {\"match\": {\"job_description\": \"TypeScript\"}},\n              {\"match\": {\"job_description\": \"MongoDB\"}},\n              {\"match\": {\"job_description\": \"AWS\"}}\n            ],\n            \"filter\": [\n              {\"range\": {\"crawled_date\": {\"gte\": \"now-21d/d\"}}}\n            ]\n          }\n        }\n      },\n      \"tags\": [\"technology\", \"development\", \"stack\"],\n      \"complexity\": \"medium\",\n      \"successRate\": 89,\n      \"performanceNotes\": \"Good balance of must/should clauses\"\n    },\n    {\n      \"id\": \"remote_work_search\",\n      \"description\": \"Find remote jobs in specific categories\",\n      \"userIntent\": \"remote work opportunity search\",\n      \"query\": {\n        \"query\": {\n          \"bool\": {\n            \"must\": [\n              {\n                \"bool\": {\n                  \"should\": [\n                    {\"match\": {\"job_description\": \"remote\"}},\n                    {\"match\": {\"job_description\": \"work from home\"}},\n                    {\"match\": {\"job_description\": \"telecommute\"}},\n                    {\"match\": {\"location\": \"remote\"}}\n                  ],\n                  \"minimum_should_match\": 1\n                }\n              },\n              {\"term\": {\"is_deleted.keyword\": \"0\"}}\n            ],\n            \"filter\": [\n              {\"range\": {\"crawled_date\": {\"gte\": \"now-14d/d\"}}}\n            ]\n          }\n        }\n      },\n      \"tags\": [\"remote\", \"flexible_work\", \"location_independent\"],\n      \"complexity\": \"medium\",\n      \"successRate\": 86,\n      \"performanceNotes\": \"Text matching works well for remote work detection\"\n    }\n  ]\n}\n```\n\n---\n\n## Testing Requirements\n\n### Unit Tests Example\n```\n// tests/agents/IntentParserAgent.test.ts\nimport { IntentParserAgent } from '../../src/background/agents/IntentParserAgent';\nimport { LLMClient } from '../../src/background/services/LLMClient';\n\ndescribe('IntentParserAgent', () => {\n  let agent: IntentParserAgent;\n  let mockLLMClient: jest.Mocked;\n\n  beforeEach(() => {\n    mockLLMClient = {\n      generateCompletion: jest.fn(),\n      testConnection: jest.fn()\n    } as any;\n    agent = new IntentParserAgent(mockLLMClient);\n  });\n\n  test('should parse simple job search query', async () => {\n    const mockResponse = JSON.stringify({\n      entities: {\n        companies: [],\n        locations: ['San Francisco'],\n        skills: ['JavaScript'],\n        jobTitles: ['Software Engineer'],\n        dateRanges: [],\n        salaryRanges: []\n      },\n      analysisType: 'search',\n      complexity: 'simple',\n      confidence: 0.9\n    });\n\n    mockLLMClient.generateCompletion.mockResolvedValue(mockResponse);\n\n    const mockContext = {\n      userInput: 'Find software engineer jobs in San Francisco requiring JavaScript',\n      schema: { mappings: { properties: {} }, version: '7.x', lastUpdated: new Date(), indexName: 'jobs' },\n      sampleQueries: [],\n      config: { provider: 'gemini', model: 'gemini-1.5-pro', temperature: 0.1, maxTokens: 4096, timeout: 30000, retryAttempts: 3 },\n      debugMode: false,\n      sessionId: 'test-session'\n    } as any;\n\n    const result = await agent.parse(\n      'Find software engineer jobs in San Francisco requiring JavaScript',\n      mockContext\n    );\n\n    expect(result.entities.jobTitles).toContain('Software Engineer');\n    expect(result.entities.locations).toContain('San Francisco');\n    expect(result.entities.skills).toContain('JavaScript');\n    expect(result.analysisType).toBe('search');\n    expect(result.complexity).toBe('simple');\n    expect(result.confidence).toBe(0.9);\n  });\n\n  test('should handle malformed LLM response', async () => {\n    mockLLMClient.generateCompletion.mockResolvedValue('Invalid JSON response');\n\n    const mockContext = {\n      userInput: 'test query',\n      schema: { mappings: { properties: {} }, version: '7.x', lastUpdated: new Date(), indexName: 'jobs' },\n      sampleQueries: [],\n      config: { provider: 'gemini', model: 'gemini-1.5-pro', temperature: 0.1, maxTokens: 4096, timeout: 30000, retryAttempts: 3 },\n      debugMode: false,\n      sessionId: 'test-session'\n    } as any;\n\n    await expect(agent.parse('test query', mockContext)).rejects.toThrow('Intent parsing failed');\n  });\n});\n```\n\n### Integration Test Example\n```\n// tests/integration/end-to-end.test.ts\nimport { AgentOrchestrator } from '../../src/background/agents/AgentOrchestrator';\n\ndescribe('End-to-End Query Generation', () => {\n  let orchestrator: AgentOrchestrator;\n\n  beforeAll(async () => {\n    // Setup test environment\n    orchestrator = new AgentOrchestrator();\n    await orchestrator.initialize();\n  });\n\n  test('should generate valid query for simple request', async () => {\n    const result = await orchestrator.processQuery('Find software engineer jobs');\n    \n    expect(result).toBeDefined();\n    expect(result.queryResults.length).toBeGreaterThan(0);\n    expect(result.queryResults.validation.isValid).toBe(true);\n    expect(result.queryResults.validation.score).toBeGreaterThan(70);\n  }, 30000);\n\n  test('should handle complex aggregation request', async () => {\n    const result = await orchestrator.processQuery('Count jobs by company in the last month');\n    \n    expect(result).toBeDefined();\n    expect(result.queryResults.query.aggs).toBeDefined();\n    expect(result.queryResults.query.size).toBe(0);\n  }, 30000);\n});\n```\n\n---\n\n## Build and Deployment Instructions\n\n### Development Setup\n```\n# 1. Clone and install dependencies\nnpm install\n\n# 2. Start development build\nnpm run dev\n\n# 3. Load extension in Chrome\n# - Open chrome://extensions/\n# - Enable Developer mode\n# - Click \"Load unpacked\"\n# - Select the dist/ folder\n\n# 4. Run tests\nnpm test\n\n# 5. Type checking\nnpm run type-check\n\n# 6. Linting\nnpm run lint\n```\n\n### Production Build\n```\n# 1. Create production build\nnpm run build\n\n# 2. Package for distribution\nnpm run package\n\n# 3. Upload elasticsearch-query-helper.zip to Chrome Web Store\n```\n\n---\n\n## Success Criteria and Acceptance Tests\n\n### Functional Requirements\n1. **FR-101**: Natural Language Input Processing\n   - ✅ Accept free-form text input\n   - ✅ Handle various query styles and formats\n   - ✅ Process input within 45 seconds\n\n2. **FR-102**: Multi-Agent Processing\n   - ✅ Intent Parser extracts entities and analysis type\n   - ✅ Perspective Agent generates analytical approaches\n   - ✅ Query Builder creates valid Elasticsearch DSL\n   - ✅ Validation Agent checks syntax and schema compliance\n   - ✅ Consensus Agent reviews and approves queries\n\n3. **FR-103**: Query Validation\n   - ✅ Syntax validation >90% accuracy\n   - ✅ Schema compliance checking\n   - ✅ Performance impact assessment\n   - ✅ Security vulnerability detection\n\n### Performance Requirements\n- **Response Time**: 85% of generated queries are syntactically correct\n- **Schema Compliance**: >95% of queries use correct field names\n- **User Satisfaction**: >75% positive feedback\n\n### Technical Requirements\n- **LLM Provider Support**: Gemini, OpenAI, Anthropic, Ollama\n- **Chrome Compatibility**: Manifest V3 compliance\n- **Error Handling**: Graceful failure recovery\n- **Debug Capabilities**: Comprehensive agent logging\n\n---\n\n## Deployment Checklist\n\n### Pre-Deployment\n- [ ] All unit tests passing\n- [ ] Integration tests passing\n- [ ] Type checking successful\n- [ ] Linting clean\n- [ ] Build generates without errors\n- [ ] Manual testing completed\n\n### Chrome Extension Package\n- [ ] manifest.json configured correctly\n- [ ] Icons included (16x16, 48x48, 128x128)\n- [ ] Permissions minimal and necessary\n- [ ] Content Security Policy configured\n- [ ] Host permissions for LLM APIs\n\n### Documentation\n- [ ] API documentation complete\n- [ ] Troubleshooting guide available\n- [ ] User guide created\n- [ ] Developer setup instructions",
  "requestFramePermissions": [],
  "name": "Elastic-Query"
}